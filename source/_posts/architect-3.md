---
title: JavaWeb笔记-Nginx D3
date: 2020-07-13 12:01:10
categories:
- [Java开发]
tags:
- [Nginx]
---

该笔记包含如下内容：HTTPS、SSL、OpenSSL自签名

<!--more-->
## HTTPS

<!-- 
这里主要介绍HTTPS的工作流程，它为什么可以保障数据的安全以及防篡改

首先提一下非对称加密算法，简单来说就是对信息加密时，加密与解密所用的密钥是不相同的，我们称用来加密的密钥为私钥，解密的密钥是公钥，因为加密用密钥是不能公开不能告诉别人的所以叫私钥；另外公私钥是成对的，通常公钥是由私钥生成的，OK到这里就可以，我们回到HTTPS

众所周知HTTP协议是不安全的，因为它所有的传输数据在网络信道上都是明文，这样非常容易造成数据的泄露以及篡改，数据泄露是不可避免的而数据篡改是最致命的，所以保证信息安全重要的一点就防止信息被篡改

<img src="/img/java/ar3/ar3-1.png" width="90%" style="text-align:center">

这里需要你发挥想象力，把小明看作浏览器，小红是服务器，云朵代表HTTP request/response的数据，这里的整个通信过程数据都是明文传输，可以看作是HTTP传输数据的一个模型，假设小明有一个情敌小黑，他可以轻而易举的拦截获得信息，并且发坏偷偷修改了小红返回给小明的信件，改为「小明我不喜欢你」，这样是很麻烦的

于是聪明的小红想了一个办法，她把传递给小明的消息加密，可是在她们之间只能通过互联网通信，没有其他的办法做通信了，那小红如何告诉小明解密的密钥呢，小红可以把密钥加密返回，可这是不行哦，这不套娃了吗，在小明不知道密钥前提下，他该如何解密一段密文获取其中的密钥？所以小红只能把密钥用明文返回了

为了能够让小明可以有办法解密，小红需要把解密的钥匙跟着密文一起发送给小明，假如小红使用了对称加密，我们来看一下会发生什么，因为小黑可以截获到信息，然后取出密钥对信息解密，小黑看完了以后在嫉妒心的驱使下修改了信息的内容，由于使用了对称加密，即加密解密是用了相同的密钥，也就是说小黑可以用截获到的密钥把自己修改的内容重新加密返回给小明，此时小明是看不出异常的，他没有办法分辨出自己得到的消息有没有被篡改

可以看出对称加密是无法防止信息被篡改的，所以小红应该使用非对称加密来杜绝上面的情况

使用非对称加密时，小红手中会持有一个私钥，这是不能公开的只有小红自己知道是什么，她用这个私钥对信息进行加密，接着将解密的公钥与密文一起作为信息内容发送给小明，假设此时不幸信息内容又双叒叕被小黑拦截到了，他能获得公钥对密文解密，但是他不能再修改内容重新加密发给小明，因为小黑手里没有私钥，无法对新信息重新加密；如果他强行加密返回给小明，小明就会发现：哎这内容中的密文用公钥解不开了，那就说明密文出现了问题，我不能信任这个消息了

<img src="/img/java/ar3/ar3-2.png" width="90%" style="text-align:center">

~~于是从此小红与小明过上了幸福生活~~，然而好景不长，小黑学聪明了


他想了一个办法，就是自己造一套公/私钥，每次拦截到小红的消息，首先拿小红的公钥解密，然后修改信息改完之后用自己的私钥把信息加密了，最后他模仿小红把信息与自己的私钥当作内容返回给小明，这样小明接收到消息可以正常的解密，但是他不知道信息与公钥被小黑已经给换了，这就是比较麻烦的中间人攻击，这个漏洞是因为协议只关心我能不能个用公钥解开密文，而不关心这个公钥的安全性

<img src="/img/java/ar3/ar3-3.png" width="90%" style="text-align:center">

为了解决这个问题出现了一个第三方机构CA，也就是通过第三方为公钥做背书的方式保证你的公钥是安全的

简单来说就是小红与小明之间在进行通信之前就与CA机构联系好，小红向CA提交自己的个人信息以及一个公钥，然后获得一个证书，你可以理解这个证书是CA把小红的个人信息与公钥一起进行了非对称加密得到的密文，当然用的是CA自己的私钥；而小明这边向CA索要他们的公钥，这样以后小红与小明在通信时，小红发送发的内容除了公钥与加密信息还有CA给自己的证书，小明在获得内容后用CA提供的公钥对内容中的证书解密，从中取出小红早早就保存在里的公钥，小明用这个公钥与内容中的公钥进行比较，如果一样说明没有问题，如果不一样就表示内容中的公钥被替换过，通过这种方式避免了中间人攻击，也就是保证了内容中公钥的安全性

<img src="/img/java/ar3/ar3-4.png" width="90%" style="text-align:center">

除此以外，如果小黑也效仿小明去要CA的公钥，其实这是没用的，对根结底是因为小黑没有CA的私钥不能篡改CA里内容，即使他同样用中间人攻击的方式替换了CA证书，由于解密CA证书的公钥早早就小明就拿到手了，所以小明拿到CA证书后一眼就知道这个CA有没有被篡改

这种方式就是我们的HTTPS的工作原理，公司用自己的域名以及公钥和公司信息去向权威的CA机构申请证书，最后把公钥、证书配置到Nginx中去，这样浏览器每次请求时都拿到这个公钥与证书，而浏览器厂家早早的就与CA取得联系能够认证证书，最后浏览器解析请求时会参考证书里的信息。

HTTPS本质还是建立了一种第三方背书的信任方式，就是我们作为用户首先你要信任浏览器，接着浏览器又信任CA机构，CA又帮用户对公司的公钥做了认证；所以间接的就是你可以相信你拿到的公钥，最终用公钥能够拿到正确的信息，还记得中间人攻击吗，他的本质就是替换了你本该拿到的公钥，所以造成了问题漏洞，而CA帮我们建立了一种相对的信任机制；~~吼吼吼而区块链就是去掉了这个第三方背书~~

最后就是即使在HTTPS中，我们依旧是把公钥以明文方式发送，这个特性就说明信息总是可以被破解的，当然这不是指信息100%不安全的，就是总有办法破解你的加密信息，但是HTTPS能保证信息难以被篡改

-->
{% note warning %} 发现自己对于HTTPS的理解过于浅薄，而且文中包含太多错误，回炉重造中... {% endnote %}
